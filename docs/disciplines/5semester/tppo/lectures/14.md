# 14. Проектирование: подсистемы и интерфейсы

## Проектирование
::: details Основная информация

Design (на английском языке) != project (включает и другие этапы помимо проектирования)

---

**Причины и роль проектирования**
1. Анализ (что решается?)
    - Планирование
2. Синтез (как?)
    - Проектирование
    - Кодирование
    - Тестирование
    - Аттестация
3. Сопровождение (что дальше?)

На стадии проектирования определяется, как и каким образом ПС будет реализовать требования, которые к ней предъявляются.

![Математические модели](../images/ПроектОбщ.png)

---
**Проектирование включает:**
1. Проектирование данных (структуры данных, форматы данных разрабатываются)
2. Проектирование архитектуры (из каких подсистем/модулей состоит ПС, как они взаимодействуют)
3. Проектирование интерфейсов подсистем

![Математические модели](../images/ВходМодульВыход.png)

4. Проектирование интерфейса пользователя (UI) 

![Математические модели](../images/ПроектUI.png)

5. Проектирование подсистем (алгоритмы программных модулей и внутренние структуры данных для подсистем)

6. Проектирование тестов (способ проверки качества системы)

![Математические модели](../images/ПроектТестов.png)

Основная причина выполнения проектирования - обеспечение качества.

---

**Характеристики качества проектирования**

1. Учтены все явные требования и есть учет неявных требований заказчика. (те требования, которые естественным образом появились при этапе разработки, в спецификации требований они не указаны, или неявные требования по типу: графический интерфейс пользователя должен быть)
	1. Как проверить? Составляется табличка:
		![Математические модели](../images/ПроверкаТребований.png)
2. Понятное и полное руководство для кодировщика и тестировщика
3. Всестронняя модель ПС 
	1. Нужно посмотреть на ПС с разных сторон и посмотреть на нее под разными углами:
		1. Данные
		2. Функциональность (какого рода функции ПС реализует)
		3. Поведение
		4. Эволюция (возможности для развития нужно закладывать на этапе проектирования)
		5. Информационная безопасность
		6. Производительность
		7. Точность результата
---

**Принципы проектирования**

1) Не использовать "взгляд через туннель"
	- Туннель - некая труба, через нее смотрим и видим маленький кусочек, того, чем нужно заниматься. Всесторонняя модель ПС говорит, что нам это мешает.  
	Мы должны предложить не частное решение, а должны быть альтернативы и обоснования выбора
2) Четкая взаимосвязь с требованиями
	- Трассируемость требований. Должны показать, где было требование такое-то и где оно отразилось (в какой подсистеме), отразить в тестах и в критериях аттестации.
	- Покрытие всех требований
3) Шаблоны проектирования
	- Не изобретать велосипед. Нужно воспользоваться уже имеющимися решениями - шаблонами архитектуры.
4) Структуризация
	- Декомпозиция (*разделение на части и решение более мелких задач*). Отдельно рассматриваем данные, функциональность, поведение, эволюция и пр.
	- Борьба со сложностью 
	- Учет возможных изменений.  
	Яркий пример - архитектура, систему разбиваем на подсистему, если нужно будет вносить правки в подсистему - изменяем лишь ее, другие - не трогаем
5) Однородность (*описание решений в одном стиле*) и интеграция (*сборка одного большого решения из множества маленьких*)
	- Разрабатываемые документы понятны всем разработчикам. Чтобы из маленьких подсистем собрать все в большую одну.
	- Командная работа, во многих проектах явно указывается, как документация оформляется
6) Учет нестандартных ситуаций
	- Подсистема обработки ошибок. 
	- Алгоритм проверки корректности данных.
	- Джентельменское поведение - ПС ведет себя как джентельмен, она будет достойно обрабатывать все случаи.
7) Проектирование != кодирование
	- Только названия файлов и функций
8) Минимальная "интеллектуальная дистанция" между ПС и поставленной задачей из практики
9) Оценка качества решений во время проектирования
	- Нужно понять, а насколько предложенное решение подходит под требования
:::

## Детальное проектирование

С одной стороны требуется детализация описания, с другой стороны нельзя переходить непосредственно к программному коду, т.к. может потеряться логическая ясность описания (за кодом не увидим алгоритма). 

![Математические модели](../images/ДетальноеПроектирование.png)

Алгоритм - модель вычислительного процесса.

## Интерфейс

Требуется четкое, формализованное описание правил взаимодействия.

Элементы:
- Набор функций и процедур для вызова других сущностей:
	- Процедура - имя, входные параметры, результат
	- Функция - частный случай процедуры, которая возвращает результат
	- API - интерфейс прикладного программирования
- Обмен сообщениями - имя, содержимое, реакция на сообщение (алгоритм обработки)
- Сигналы (события) - частный случай сообщения
	- имя, реакция подсистемы на сообщение, описание сигнала
- Потоки данных (конвейеры и фильтры)
	- формат, объем, интенсивность потока, схема получения (сеть, файл, общая память подсистем)

### Описание интерфейса
Для каждого элемена описываем:
- Что элемент делает, входные/выходные данные
- Описание стандартных и нестандартных ситуаций (например, корректность данных, запреты (как нельзя пользоваться, а еще как надо пользоваться в явном виде записываем))
- Таблицы взаимодействия подсистем:

![Математические модели](../images/ГрафТаблицаВзаимодействия.png)

Ассиметричное взаимодействие может быть!  
То есть в примере 1 -> 3 и все, 3 не взаимодействует с 1.

Вместо функций можем более детально характеризовать, что у нас за интерфейс. Может быть дополнительное описание, как соответствующее взаимодействие идет.

