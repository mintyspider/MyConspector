# 14. Ахо - Корасик.

## Определения

::: info <span class="defn">Опр.</span> **Конечный автомат** - ориентированный граф, на ребрах которого находятся символы и существуют начальные (стартовые) и конечные (терминальные) вершины. 
:::

::: info <span class="defn">Опр.</span> **Префиксное дерево** или бор (англ. trie) — это структура данных для компактного хранения строк.

Он устроен в виде дерева, где на ребрах между вершинами написана символы, а некоторые вершины помечены терминальными. Бор хранит ровно те строки, которые получаются, если выписать подряд все буквы на путях от корня до терминальных вершин. 

![](../images/Бор.png)

Бор состоит из ссылающихся друг на друга вершин. В вершине обычно хранится такая информация:
+ терминальная ли вершина,
+ ссылки на детей.

Чтобы добавить слово в бор, нужно пройти от корня по символам слова. Если перехода по для очередного символа нет — создать его, иначе пройти по уже существующему. Последнюю вершину нужно пометить терминальной.

Чтобы проверить, есть ли слово в боре, нужно пройти от корня по символам слова. Если в конце оказались в терминальной вершине — то есть. Если оказались в нетерминальной или когда-нибудь потребовалось пройтись по несуществущей ссылке — то нет.

Удалить слово можно лениво, просто дойдя до него и убрав флаг терминальности.
:::

::: info <span class="defn">Опр.</span> **Суффиксная ссылка** для вершины v — это вершина, в которой оканчивается наидлиннейший собственный суффикс строки, соответствующей вершине v. 

Понятно, что для корня суффиксная ссылка должна вести в себя, так как мы не должны прекращать поиск по бору в случае, если не можем по какому-то символу выйти из корня.
:::

Алгоритм Ахо-Корасик реализует эффективный поиск всех вхождений всех строк-образцов в заданную строку.

## Постановка задачи
---
Дан словарь $D={a_1,...,a_n}$ и строка s. Необходимо найти все позиции, где строки словаря входят в текст.  
Решать эту задачу будем следующим образом. Будем обрабатывать символы текста по одному и поддерживать наибольшую строку, являющуюся
1. префиксом строки из словаря
2. суффиксом считанного на данный момент текста

Если эта строка совпадает с какой-то $a_i$, то отметим текущий символ — в нём заканчивается текущая строка $a_i$. Для этой задачи нам нужно как-то эффективно хранить и работать со всеми префиксами слов из словаря — для этого нам и понадобится префиксное дерево.

Добавим все слова в префиксное дерево и пометим соответствующие им вершины как терминальные. Теперь наша задача состоит в том, чтобы при добавлении очередного символа быстро находить вершину в префиксном дереве, которая соответcтвует наидлиннейшему входящему в бор суффиксу нового выписанного префикса. Для этого нам понадобятся несколько вспомогательных понятий.

::: info <span class="defn">Опр.</span> **Суффиксная ссылка** l(v) ведёт в вершину u≠v, являющуюся наидлиннейшим собственным суффиксом строки v, принимаемым бором.
:::

::: info <span class="defn">Опр.</span> **Автоматный переход** g(v,c) ведёт в вершину u, которая соответствует минимальному принимаемому бором суффиксу строки v+c. Если такой переход есть в боре, то автоматный переход ведёт туда же.
:::

Нам нужно заметить, что
+ l(s0:n)=g(l(s0:n−1),sn)
+ Если не существует прямого перехода v⟶cu, то g(v,c)=g(l(v),c)

Этими свойствами мы воспользуемся при реализации поиска суффиксных ссылок и автоматных переходов.

## Реализация через поиск в ширину

```cpp
struct Vertex {
    map<int, Vertex*> to;
    Vertex *link;
};

void bfs(Vertex *root) {
    queue<Vertex*> q;
    // сразу проставим ссылку корню и его детям
    root->link = root;
    for (auto pair : root->to) {
        pair.second->link = root;
        // запушим детей в очередь, чтобы начать со второго слоя бора
        q.push(pair.second);
    }
    // идём обычным бфсом
    while (!q.empty()) {
        // достали вершину
        auto v = q.front();
        q.pop();
        // обойдём всех потомков, для которых есть переход в боре
        for (auto pair : v->to) {
            int parent_char = pair.first;
            Vertex *child = pair.second;
            Vertex *parent_suffix = v->link; // нашли максимальный суффикс родителя
            Vertex *next_suffix = parent_suffix->to[parent_char]; // нашли переход из суффикса родителя по заданному символу
            child->link = next_suffix; // присвоили это значение ребёнку
            q.push(child); // запушили ребёнка в очередь
        }
    }
}
```
 В момент, когда мы построили префиксное дерево, мы можем запустить на нём bfs, который сделает ровно то же самое, только более явно. Также в этом случае мы можем попробовать обойтись без массива автоматных переходов — так как все суфф-ссылки будут посчитаны заранее, нам не нужно хранить какую-то дополнительную информацию, чтобы через неё лениво пересчитывать переходы.

Для корня и его прямых потомков ссылка, как уже было сказано выше, должна вести в корень. Для каждой последующей вершины нам нужно обращаться к потомку и пытаться по заданному символу сделать переход из суффиксной ссылки.
