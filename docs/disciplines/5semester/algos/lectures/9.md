# 9. Максимальное паросочетание. Алгоритм Куна.

## Максимальное паросочетание

::: info <span class="defn">Опр.</span> **Двудольный граф** - граф без циклов нечетной длины.
:::

::: info <span class="defn">Опр.</span> **Паросочетание** - множество попарно несмежных ребер (есмежных по вершинам).
:::

::: info <span class="defn">Опр.</span> **Мощность** паросочетания - количество ребер в нем.
:::

Посмотрим на макс. паросочетание(паросочетание, максимальное по мощности), такое M, |M| -> max.

::: info <span class="defn">Опр.</span> **Совершенное паросочетание** - паросочетание, в которое включены все $a_i$ (вершины левой доли)
:::

Вершины **насыщенны** паросочетанием, если несколько вершин из левого и из правого соединены попарно.

### Теорема Бержа
> Паросочетание максимально <=> нет увеличивающих цепей относительно него. (если в паросочет. не можем найти увеличивающих цепей, то оно максимально -> никогда не найдем увеличивающей цепи)

Чтобы рассмотреть теорему, нужны определения.
::: info <span class="defn">Опр.</span> **Цепь** - это простой путь длины k.(такой путь, проходящий по всем вершинам и ребрам один раз) ![[Алгосы, 4 лекция, цепь]]
:::

::: info <span class="defn">Опр.</span> **Чередующая цепь относительно паросочетания** - путь, в котором ребро добавлено или не добавлено в паросочетании. Может быть любой длины, может начинаться с невзятого и взятого ребра в паросочетании.
:::

::: info <span class="defn">Опр.</span> **Увеличивающая цепь** - чередующая цепь, в которой первое и последнее ребро не взято (то есть цепь сверху не только чередующ., но и увеличивающая). Увеличивающая, т.к. можем увеличить на единицу. 
:::

Это значит, что мы можем искать макс. паросочетания втупую - для каждого паросочетания найдем увеличивающую цепь, а далее инвертируем ребра. Если не найдем увел. цепей - то паросочетание максимально

#### Доказательствово теоремы

МОП. Пусть есть 2 паросочетания: A есть в данный момент, а B - макс. паросочет. 

|A| <= |B| 

Пусть у А нет увел. цепей.

Если |A| = |B| - нет увел. цепей и равно макс, значит, оно макс. - не интересно.

Рассмотрим |A| < |B|и придем к противоречию:

Пусть граф неор. , рассмотрим i - j. 

$$(i-j) = \begin{cases} красный\ \in A \\ синий\ \in A, \\ зеленый\ \in A , \in B\end{cases}$$

Тогда:
1. Цикл четной длины -> (одинаковое число красных и синих ребер) получается равенство, а самих ребер должно быть больше, неинтересно
2. Путь черной длины -> (одинаковое число красных и синих ребер) получается равенство, а самих ребер должно быть больше, неинтересно
3. Путь нечетной длины -> увеличивающая цепь. Противоречие, так как после инверсии можем увеличить А, которое по условию максимально, а такой ситуации быть не должно.
4. Цикла нечетной длины не существует, так как нарушается определение паросочетания (будут связаны вершины одной доли).

Получаем цепь увеличивающую (то есть строим подграф из ребер, принадлежащих отдельным множествам (красные и синие)) (зеленые не рассматриваем, т.к. они и в А, и в В входят)

## Алгоритм Куна

Будет паросочетания строить инкрементально (изначально в нашем паросочететании нет ребра, будем искать увеличивающую цепь и будет добавлять, и как не будет увеличивающей цепи - получили максимальное паросочетание) и чередовать ребра в этом пути. 

Посмотрим на две доли независимо, и пронумеруем их также независимо, дальше скажем, что в графе из левой доли ходить в любую вершинку правой доли (ориентируем ребра), а из правой доли - только если добавлено в паросочетание ребро. Зачем? Тогда легче искать увел. цепь! Необходимо найти всего лишь цепь, которая начинается вершинки, недобавленной в паросочет., и заканчивается где-то в правой доли, в той вершинке, которая не добавлена в паросочетание. Будем хранить в виде списка смежности (для вершинки в левой доли), а для вершин правой доли - массив.

```cpp
mt[4] = 4 // ребро взятое в паросочетание ведет в вершинку левой доли (это для правой доли массив)
<vector<int>>g[MaxN]; // для левой доли
int was[N] // только для вершин левой доли, т.к. dfs вызываем из этих вершин
// в dfs возвращаем true, если нашли увел. цепь, причем будет вызываться от вершинки в левой доли

bool dfs(int v) {
	if (was[v]) // зашли, и не нашли увел. цепи(иначе паросочет. изменили бы)
		return false;
	was[v] = 1;
	// переберем все вершины из правой доли
	for(auto to : g[v]){ // нас интересуют те правые вершины, для которых в массиве mt нет отметки
		if (mt[to] == -1 || dfs(mt(to) == 1)) {// нашли увел. цепь, либо она уже находится с кем-то в паросочетании, рекурсивно запустим от той, с кем она смежна. и смотрим, найдем ли там увел. цепь(почему? наш dfs ищет тот путь, начинающ. в левой вершинке, которая не насыщена. мы идем вправо из лева, далее снова в лева, и снова вправо, это увелич. цепь какая-то) . в таком случае нашли увел. цепь. нужно чередовать. теперь говорим, что
			mt[to] = v; // чередуем
			return true;
		}
		
	
	}
	return false;

}
```

Алгоритм ровно $n$ раз ищет увеличивающий путь, каждый раз просматривая не более $m$ рёбер, а значит суммарно отработает за $O(nm)$.
