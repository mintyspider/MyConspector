# 13. Сравнение строк с помощью полиномиального хеширования.

## Определения

::: info <span class="defn">Опр.</span> **Хеш-функцией** от строки будем называть функцию, которая данной на вход строке ставит в соответствие некоторое число. При этом число, называемое *хешем* (от англ. *hash*) должно обладать следующим свойством: если строки одинаковы, то их хеши равны между собой. Обратное может быть неверно.
:::

Пусть дана строка $c = c_0c_1\dots c_n$. Поставим в соответствие каждому символу $c_i$ уникальное число $s_i$. В си-подобных языках это можно сделать таким или схожим образом:
```cpp
int s = (int) (c - 'a' + 1);
```

::: info <span class="defn">Опр.</span> **Прямой полиномиальный хеш** – это значение многочлена: 

$$h = (s_0 + s_1*k + s_2*k^2 + \dots s_n*k^n)\mod p$$

Здесь $k$ – произвольное число больше $\max s_i$, а $p$ – достаточно большой модуль, необходимый, чтобы быстрорастущие значения  хешей не приводили к переполнению.
:::

Его можно посчитать за линейное время, поддерживая переменную, равную $k$ в нужной степени:
```cpp
const int k = 31, mod = 1e9+7;

string s = "abacabadaba";
long long h = 0, m = 1;

for (char c : s) {
    int x = (int) (c - 'a' + 1);
    h = (h + k * x) % mod; // Прибавление следующего члена суммы
    // Здесь в роли k выступает m, которая каждый раз домножается на k
    m = (m * k) % mod;     
}
```


## Коллизии

<span class="defn">Опр.</span> **Коллизия** – ситуация, когда строки неодинаковы, но их хеши равны.

Хорошие хеш-функции допускают коллизии очень редко, однако не могут гарантировать их отсутствие. Для детерминированности результата работы хешей нужны дополнительные проверки, которые ухудшают асимптотику.

## Поиск подстроки с помощью полиномиального хеширования

Пусть даны исходная строка $heystack$ длины $n$ и искомая строка $needle$ длины $m$. Определим массив $hash$ следующим образом: $hash[0] = 0$, $hash[i]$ – полиномиальный хеш префикса $heystack$ длины $i$. 

Тогда, чтобы найти $hash[l\dots r]$ достаточно посчитать за $O(1)$ следующее выражение:

$$hash[l\dots r] = \frac{hash[r] - hash[l]}{k^l}$$

Действительно,
$$
\begin{multline}
hash[r] = heystack[0] + heystack[1] * k + \dots + heystack[r] * k ^ r =\\
= heystack[0] + heystack[1] * k + \dots + heystack[l] * k ^ l + \dots + heystack[r] * k^r =\\ 
= hash[l] + k^l(hash[l\dots r]) 
\end{multline}
$$
Шаги алгоритма:
1. Посчитать хеш $needle$ и всех префиксов $heystack$.
2. Для каждого $l < n - m + 1$ посчитать $hash[l\dots l + m]$.
3. Если $p$ и $k$ подобраны хорошо (так, чтобы не возникало коллизий), то $hash[l\dots l + m] == hash(needle) \Rightarrow heystack[l\dots l + m] == needle$. 

## Асимптотика

Хеш для всех префиксов $heystack$ считается за $O(n)$. $hash[l\dots l + m]$ считается за $O(1)$ для $n-m$ символов, т.е. тоже за $O(n)$. Таким образом, итоговая асимптотика алгоритма: $O(n)$.
