# 15. Префикс функция, Алгоритм Кнута – Морриса – Пратта.

## Определения

<span class="defn">Опр.</span> **Префиксом** строки $l$ называется такая подстрока $p$, что $p$ начинается с начального символа строки $l$.

<span class="defn">Опр.</span> Префикс называется **собственным**, если длина префикса не равна длине строки. 

<span class="defn">Опр.</span> **Суффиксом** строки $l$ называется такая подстрока $s$, что $s$ заканчивается конечным символом строки $l$.

<span class="defn">Опр.</span> Суффикс называется **собственным**, если длина суффикса не равна длине строки. 

<span class="defn">Опр.</span> Пусть дана строка $l$. Обозначим $l_i$ префикс $l$ до $i$-ой позиции включительно. **Префикс-функцией строки $l$** называется массив, в котором на $i$-ой позиции стоит длина наибольшего собственного префикса $l_i$, который является и суффиксом $l_i$.

<u>Замечание.</u> На нулевой позиции префикс-функции всегда будет стоять $0$, так как для строки из единственного символа и собственный префикс, и собственный суффикс будет пустой строкой.

## Префикс-функция

::: info <span class="defn">Опр.</span> **Префикс-функция строки π(S,i)** – это длина наибольшего префикса строки S[1..i], который не совпадает с этой строкой и одновременно является ее суффиксом. Проще говоря, это длина наиболее длинного начала строки, являющегося также и ее концом.
:::

Предположим, что π(S,i)=k. Отметим следующие свойства префикс-функции.
1. Если S[i+1]=S[k+1], то π(S,i+1)=k+1.
2. S[1..π(S,k)] является суффиксом строки S[1..i]. Действительно, если строка S[1..i] оканчивается строкой S[1… π(S,i)]=S[1..k], а строка S[1..k] оканчивается строкой S[1..π(S,k)], то и строка S[1..i] оканчивается строкой S[1..π(S,k)].
3. ∀ j∈(k,i), S[1..j] не является суффиксом строки S[1..i]. В противном случае было бы неверным предположение π(S,i)=k, так как j>k.

### Поиск подстроки в строке с помощью префикс-функции

Пусть π(S,i)=k. Необходимо вычислить π(S,i+1).
1. Если S[i+1]=S[k+1], то π(S,i+1)=k+1.
2. Иначе, если k=0, то π(S,i+1)=0.
3. Иначе положить k:=π(S,k) и перейти к шагу 1.

Ключевым моментом для понимания сути алгоритма является тот факт, что если найденный на предыдущем шаге суффикс не может быть расширен на следующую позицию, то мы пытаемся рассматривать меньшие суффиксы до тех пор, пока это возможно.

Заведем функцию. которая будет вычислять значение префикс-функции. 

```python
def prefix(s):
    v = [0]*len(s)
    for i in xrange(1,len(s)):
        k = v[i-1]
        while k > 0 and s[k] <> s[i]:
            k = v[k-1]
        if s[k] == s[i]:
            k = k + 1
        v[i] = k
    return v
```
Асимптотика будет суммироваться, т.к. while не полностью за O(n) работает, получается O(n).

## Алгоритм Кнута – Морриса – Пратта

Алгоритм Кнута-Морриса-Пратта, основанный на использовании префикс-функции. При помощи префикс-функции мы можем избежать заведомо бесполезных сдвигов.

```python
def kmp(s,t):
    index = -1
    f = prefix(s)
    k = 0
    for i in xrange(len(t)):
        while k > 0 and s[k] <> t[i]:
            k = f[k-1]
        if s[k] == t[i]:
            k = k + 1
        if k == len(s):
            index = i - len(s) + 1
            break
    return index
```
Пусть S[0..m–1] – образец, T[0..n–1] – строка, в которой ведется поиск. Рассмотрим сравнение строк на позиции i, то есть образец S[0..m–1] сопоставляется с частью строки T[i..i+m–1]. Предположим, первое несовпадение произошло между символами S[j] и T[i+j], где i < j < m. Обозначим P = S[0..j–1] = T[i..i+j–1]. При сдвиге можно ожидать, что префикс S сойдется с каким-либо суффиксом строки P. Поскольку длина наиболее длинного префикса, являющегося одновременно суффиксом, есть префикс-функция от строки S для индекса j, приходим к следующему алгоритму:
1. Построить префикс-функцию образца S, обозначим ее F.
2. Положить k = 0, i = 0.
3. Сравнить символы S[k] и T[i]. Если символы равны, увеличить k на 1. Если при этом k стало равно длине образца, то вхождение образца S в строку T найдено, индекс вхождения равен i – |S| + 1. Алгоритм завершается. Если символы не равны, используем префикс-функцию для оптимизации сдвигов. Пока k > 0, присвоим k = F[k–1] и перейдем в начало шага 3.
4. Пока i < |T|, увеличиваем i на 1 и переходим в шаг 3.