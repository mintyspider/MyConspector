# 3. Кратчайшие пути. Виды задач поиска кратчайших путей. Поиск кратчайших путей в бесконтурном графе. Про один алгоритм рассказать подробнее.

::: details Оффтопик для понимания происходящего
Вспоминаем ЕГЭ по информатике :)  
У нас есть 2 варианта, что такое кратчайший путь, и он зависит от вида графа:
+ В орграфе мы можем двигаться только согласно направлениям ребер, в неориентированном - как угодно.
+ Мы ищем либо минимальный по *числу ребер* путь, либо по *весу*, если вдруг дан граф с весами. Так что внимательно читаем задание.  
:::

## Кратчайшие пути

::: info Основные определения вопроса 
<span class="defn">Опр.</span> **Кратчайшим путем** между вершинами $а$ и $b$ в графе называется путь между ними, содержащий наименьшее количество ребер.

<span class="defn">Опр.</span> **Взвешенным графом** называется граф, в котором каждому ребру сопоставляется число, называемое *весом*, *длиной* или *стоимостью*.

<span class="defn">Опр.</span> Во взвешенных графах **длиной пути** называется суммарная длина всех его ребер от $а$ до $b$.
:::

Кратчайший путь - минимальный по *числу ребер* либо по *весу* (у взвешенного графа) путь.

## Виды задач поиска кратчайших путей

Это классическая задача на графы, нужно найти меньший вес - самый короткий по длине путь в графе.

Задача нахождение кратчайшего пути имеет несколько тесно связанных вариаций: 
- Нахождение кратчайшего пути между заданной парой вершин $u$ и $v$.
- Нахождение кратчайших путей между заданной вершиной $u$ и всеми остальными вершинами в графе.
- Нахождение кратчайших путей между каждой парой вершин в графе.

## Поиск кратчайших путей в бесконтурном графе

<span class="defn">Опр.</span> *Контуром* называется замкнутый путь в орграфе.

Соответственно, бесконтурный граф не содержит путь, в котором первая вершина совпадает с последней.  

::: details Немного о том, почему кратчайшее расстояние существует
Пусть есть вершинка S - исток и t - , $d_s$[i] - кратчайшее расстояние от вершинки S до вершинки i.  
Рассмотрим кратчайшее расстояние:
$p: \{S -> a_1 -> a_2 -> a_3 -> ... -> a_i -> ... -> a_k -> t\}$

Докажем, что путь от S до $a_i$ - кратчайший

МОП: пусть есть другой путь, его длина $d_2$ , а $d_1$ - исходный путь.

$d_2$ < $d_1$

Значит уже не кратчайший (так как $d_3$ - путь от $a_i$ до t)

$d_1 + d_3$ 
$d_2 + d_3$

Если есть один кратчайший путь, значит он проходит по всем кратчайшим путям. Чтд :)

![](../images/Циклик.jpg)

Кстати про циклы, если:
1) d = 0 (длина цикла = 0 -> сомнительно, но ОК)
2) d > 0 -> вообще не ходить, этот цикл увеличивает длину пути
3) d < 0 (длина пути отрицательна) -> в таком случае кратчайшего пути не существует (т.к. можем ходить по циклу, будет все меньше и меньше путь, значит нет смысла искать кратчайший путь)
:::

Нахождение кратчайшего пути возможно 2 путями:
+ Жадным алгоритмом (алгоритм Дейкстры за $O(|V|^2)$)
+ Динамическим программированием (алгоритм Форда-Беллмана за $O(|V|*|E|)$, алгоритм Флойда-Уоршелла за $O(|V|^3)$)

### Базовые алгоритмы нахождения кратчайших путей

1. *Алгоритм Флойда-Уоршелла*: находит расстояние от каждой вершины до каждой за $O(|V|^3)$ операций.
2. *Алгоритм Форда-Беллмана*: находит расстояние от одной вершины до всех остальных за $O(|V| * |E|)$ операций.
3. *Алгоритм Дейкстры*: находит расстояние от одной вершины до всех остальных за $O(|V|^2)$ операций.
4. *Алгоритм Дейкстры для разреженных графов*: делает то же самое, что и алгоритм Дейкстры, но за $O((|V|+|E|) * log(|V|))$ операций.

### Кратчайшие пути в графе (с весами)

Это классическая задача на графы, нужно найти меньший вес - самый короткий по длине путь.

Список смежности в таких задачах : 1 : (2, 5) - пара из номера вершины и веса 

```cpp
vector <vector<pair<int,int>>> g;
int u, v, w;
cin >> u >> v >> w;
g[u].push_back({v,w}, {u,w})
```

Матрицу смежности плохо использовать по памяти (O$n^2$).

Список смежности будет хуже, когда хотим узнать вес (O(1)), когда у матрицы смежности O(n).

У нас есть граф с вершинами и весами. Выбираем минимум среди вершин, красим ее.

## Про один алгоритм рассказать подробнее

Теперь у вас есть выбор, так как мы разбирали 3 алгоритма, предоставляю все 3 на выбор:

### 1. Алгоритм Дейкстры

> (Dijkstra - голландский математик)

+ Находит расстояние от одной вершины до всех остальных за n^2 операций.
+ Все веса неотрицательны.
+ Использует массивы mark[0…n — 1] и d[0…n — 1] для хранения помеченных и непомеченных вершин соответственно.
+ На каждой итерации находит вершину с наименьшим значением в d среди непомеченных и помечает её.
+ Временная сложность порядка $O(n^2)$, где (n) — количество вершин в графе.

```cpp
прочитать g // g[0 ... n - 1][0 ... n - 1] - массив, в котором хранятся веса рёбер, g[i][j] = 2000000000, если ребра между i и j нет
d = g
d[0] = 0
mark[0] = True
for i = 1 ... n - 1
    mark[i] = False
for i = 1 ... n - 1
    v = -1
    for i = 0 ... n - 1
        if (not mark[i]) and ((v == -1) or (d[v] > d[i]))
            v = i
    mark[v] = True
    for i = 0 ... n - 1
        if d[i] > d[v] + g[v][i]
            d[i] = d[v] + g[v][i]
вывести d
```
> Алгоритм работает следующим образом:
> 1. Инициализирует массив d значениями из матрицы g, где g[i][j] хранит вес ребра между вершинами i и j, а g[i][j] = 2000000000 означает отсутствие ребра.
> 2. Устанавливает начальную вершину (с индексом 0) как помеченную и её расстояние до самой себя равным 0.
> 3. В цикле для каждой непомеченной вершины находит вершину с наименьшим текущим расстоянием d[v].
> 4. Помечает эту вершину и обновляет расстояния до соседних вершин, если новое расстояние меньше текущего.
> 5. Повторяет шаги 3–4 до тех пор, пока все вершины не будут помечены.

#### Алгоритм Дейкстры для разреженных графов

+ Делает то же самое, что и алгоритм Дейкстры, но за (n + m) * log(n) операций.
+ Использует двоичную кучу для хранения пар из номера вершины и d[v].
+ Обновляет значение d в куче, проверяя фиктивные элементы.
+ Использует массив списков для записи графа.
+ Временная сложность порядка $O((n + m) * log(n))$, где m — количество рёбер, а n — количество вершин.

```cpp
прочитать g // g[0 ... n - 1] - массив списков, в i-ом списке хранятся пары: first - вершина, соединённая с i-ой вершиной ребром, second - вес этого ребра
d[0] = 0
for i = 0 ... n - 1
    d[i] = 2000000000
for i in g[0] // python style
    d[i.first] = i.second
    q.add(pair(i.second, i.first))
for i = 1 ... n - 1
    v = -1
    while (v = -1) or (d[v] != val)
        v = q.top.second
        val = q.top.first
    q.removeTop
    mark[v] = true
    for i in g[v]
        if d[i.first] > d[v] + i.second
            d[i.first] = d[v] + i.second
            q.add(pair(d[i.first], i.first))
вывести d
```
> В коде используется массив d, который хранит текущие расстояния от начальной вершины до каждой другой вершины. Изначально все расстояния устанавливаются в большое число (2 000 000 000), кроме расстояния от начальной вершины до самой себя, которое равно 0. Затем код проходит по рёбрам графа, обновляя расстояния в массиве d и добавляя вершины в кучу q.

### 2. Алгоритм Форда-Беллмана

+ Находит расстояние от одной вершины до всех остальных за n * m операций.
+ Аналогично алгоритму Флойда-Уоршелла, веса могут быть отрицательными, но не могут быть циклов с отрицательной суммой весов рёбер.
+ Использует массив d[0…n — 1] для хранения ответов.
+ Обновляет массив, проходя по каждому ребру и улучшая расстояние до вершин, которые оно соединяет.
+ Временная сложность порядка $O(n * m)$, где n — количество вершин, а m — количество рёбер.

```cpp
прочитать e // e[0 ... m - 1] - массив, в котором хранятся рёбра и их веса (first, second - вершины, соединяемые ребром, value - вес ребра)
for i = 0 ... n - 1
    d[i] = 2000000000
d[0] = 0
for i = 1 ... n
    for j = 0 ... m - 1
        if d[e[j].second] > d[e[j].first] + e[j].value
            d[e[j].second] = d[e[j].first] + e[j].value
        if d[e[j].first] > d[e[j].second] + e[j].value
            d[e[j].first] = d[e[j].second] + e[j].value
вывести d
```
> В начале работы алгоритма создаётся массив d размером n, где n — количество вершин в графе, и все его элементы инициализируются большим числом (2 000 000 000), что символизирует бесконечность. Значение d[0] устанавливается равным 0, так как предполагается, что мы ищем пути от вершины с номером 0. Затем алгоритм выполняет n итераций, на каждой из которых он проходит по всем рёбрам графа и пытается обновить расстояния до вершин, которые они соединяют, если новое расстояние меньше текущего.

### 3. Алгоритм Флойда-Уоршелла

+ Находит расстояние от каждой вершины до каждой за n^3 операций.
+ Веса могут быть отрицательными, но не могут быть циклов с отрицательной суммой весов рёбер.
+ Использует массив d[0…n — 1][0…n — 1] для хранения ответов.
+ На каждой итерации обновляет массив, используя вершины с номером строго меньше i — 1.
+ Временная сложность порядка $O(n^3)$, где n — количество вершин.

```cpp
прочитать g // g[0 ... n - 1][0 ... n - 1] - массив, в котором хранятся веса рёбер, g[i][j] = 2000000000, если ребра между i и j нет
d = g
for i = 1 ... n + 1
     for j = 0 ... n - 1
          for k = 0 ... n - 1
              if d[j][k] > d[j][i - 1] + d[i - 1][k]
                  d[j][k] = d[j][i - 1] + d[i - 1][k]
вывести d
```
> Алгоритм работает следующим образом: изначально создаётся матрица d, которая копирует матрицу g, содержащую веса рёбер графа. Затем выполняется тройной цикл, который перебирает все возможные пары вершин и проверяет, можно ли улучшить путь между ними через промежуточную вершину. Если сумма весов путей от j до i-1 и от i-1 до k меньше текущего значения d[j][k], то d[j][k] обновляется. Это повторяется n+1 раз, где n — количество вершин в графе.

### Если все совсем плохо - решение динамичским программированием

Например, чтобы найти кратчайшее расстояние от заданной вершины до всех остальных можно использовать динамическое программирование:

$$d_v​= \underset{(u,v)\in E}{\min}​(d_u​+w_{uv}​)$$

Транспонируем граф и переведем его в формат списков смежности, то есть для каждой вершины составим список ведущих в неё ребер с их весами:

```cpp
vector < pair <int, int> > t[N]; // куда ведет ребро и его вес
```

Заведем массив $d$, в котором мы для каждой вершины будем хранить расстояние от изначальной вершины — для удобства будем считать, что у неё нулевой номер. Для всех ячеек кроме первой этот массив изначально будет заполнен «бесконечностью» — некоторым числом, которое заведомо больше, чем любое правильное расстояние.

```cpp
vector<int> d(n, inf);
d[0] = 0;
```

Теперь, проходясь по вершинам графа в порядке какой-нибудь [топологической сортировки](https://ru.algorithmica.org/cs/graph-traversals/topological-sorting) — которую можно найти как отдельным обходом, так и как-нибудь неявно — будем _релаксировать_ (обновлять более оптимальным значением) расстояние до $v$, рассматривая его обратные ребра по формуле ниже:

```cpp
for (int v = 1; u < n; u++)
    for (auto [u, w] : t[v])
        d[v] = min(d[v], d[u] + w);
```

Такой алгоритм очень простой и работает за $O(m)$, где m - число ребер графа.