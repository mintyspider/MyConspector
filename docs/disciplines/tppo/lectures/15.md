# 15. Проектирование: интерфейс пользователя

## Проектирование
::: details Основная информация

Design (на английском языке) != project (включает и другие этапы помимо проектирования)

---

**Причины и роль проектирования**
1. Анализ (что решается?)
    - Планирование
2. Синтез (как?)
    - Проектирование
    - Кодирование
    - Тестирование
    - Аттестация
3. Сопровождение (что дальше?)

На стадии проектирования определяется, как и каким образом ПС будет реализовать требования, которые к ней предъявляются.

![Математические модели](../images/ПроектОбщ.png)

---
**Проектирование включает:**
1. Проектирование данных (структуры данных, форматы данных разрабатываются)
2. Проектирование архитектуры (из каких подсистем/модулей состоит ПС, как они взаимодействуют)
3. Проектирование интерфейсов подсистем

![Математические модели](../images/ВходМодульВыход.png)

4. Проектирование интерфейса пользователя (UI) 

![Математические модели](../images/ПроектUI.png)

5. Проектирование подсистем (алгоритмы программных модулей и внутренние структуры данных для подсистем)

6. Проектирование тестов (способ проверки качества системы)

![Математические модели](../images/ПроектТестов.png)

Основная причина выполнения проектирования - обеспечение качества.

---

**Характеристики качества проектирования**

1. Учтены все явные требования и есть учет неявных требований заказчика. (те требования, которые естественным образом появились при этапе разработки, в спецификации требований они не указаны, или неявные требования по типу: графический интерфейс пользователя должен быть)
	1. Как проверить? Составляется табличка:
		![Математические модели](../images/ПроверкаТребований.png)
2. Понятное и полное руководство для кодировщика и тестировщика
3. Всестронняя модель ПС 
	1. Нужно посмотреть на ПС с разных сторон и посмотреть на нее под разными углами:
		1. Данные
		2. Функциональность (какого рода функции ПС реализует)
		3. Поведение
		4. Эволюция (возможности для развития нужно закладывать на этапе проектирования)
		5. Информационная безопасность
		6. Производительность
		7. Точность результата
---

**Принципы проектирования**

1) Не использовать "взгляд через туннель"
	- Туннель - некая труба, через нее смотрим и видим маленький кусочек, того, чем нужно заниматься. Всесторонняя модель ПС говорит, что нам это мешает.  
	Мы должны предложить не частное решение, а должны быть альтернативы и обоснования выбора
2) Четкая взаимосвязь с требованиями
	- Трассируемость требований. Должны показать, где было требование такое-то и где оно отразилось (в какой подсистеме), отразить в тестах и в критериях аттестации.
	- Покрытие всех требований
3) Шаблоны проектирования
	- Не изобретать велосипед. Нужно воспользоваться уже имеющимися решениями - шаблонами архитектуры.
4) Структуризация
	- Декомпозиция (*разделение на части и решение более мелких задач*). Отдельно рассматриваем данные, функциональность, поведение, эволюция и пр.
	- Борьба со сложностью 
	- Учет возможных изменений.  
	Яркий пример - архитектура, систему разбиваем на подсистему, если нужно будет вносить правки в подсистему - изменяем лишь ее, другие - не трогаем
5) Однородность (*описание решений в одном стиле*) и интеграция (*сборка одного большого решения из множества маленьких*)
	- Разрабатываемые документы понятны всем разработчикам. Чтобы из маленьких подсистем собрать все в большую одну.
	- Командная работа, во многих проектах явно указывается, как документация оформляется
6) Учет нестандартных ситуаций
	- Подсистема обработки ошибок. 
	- Алгоритм проверки корректности данных.
	- Джентельменское поведение - ПС ведет себя как джентельмен, она будет достойно обрабатывать все случаи.
7) Проектирование != кодирование
	- Только названия файлов и функций
8) Минимальная "интеллектуальная дистанция" между ПС и поставленной задачей из практики
9) Оценка качества решений во время проектирования
	- Нужно понять, а насколько предложенное решение подходит под требования
:::

## Золотые правила разработки интерфейса

### 1. Пользователь - центральный элемент управления
> Пользователь всегда прав!

1. Не требовать от пользователя лишнего (повтор информации) или неожиданного (экраны в разном стиле).
2. Гибкость (система должна подстраиваться под пользователя: настройка, выбор альтернатив на усмотрение пользователя (формат файла, стиль, меню, горячие клавиши))
3. Undo и Cancel - возможность прервать цепочку действий в любой момент: откат назад, отмена действия.
4. Скрытие технических деталей от обычного пользователя (код и подробное описание ошибок)
5. Непосредственное взаимодействие с объектами на экране (меню, кнопки, окошки, надписи)
6. Подтверждение деструктивных действий (при удалении или изменении данных запросить подтверждение)

### 2. Малая загрузка памяти пользователя
> Чем больше надо помнить, тем больше ошибок совершает пользователь. Поэтому не надо заставлять пользователя много запоминать.

1. Уменьшение потребности в кратковременной памяти (на экране частично отобразить основную информацию, введенную ранее)

2. Определение осмысленных установок по умолчанию (placeholder, известные ранее данные)

3. Интуитивные сокращения, обозначения, визуальные элементы (компактное отображение)

4. Структуризация (весь интерфейс разбивается на части - декомпозиция или иерархия)

### 3. Согласованность
> Все элементы интерфейса оформлены по общим правилам

1. Унификация (однородность, одинотипность, схожесть команд, меню, цветовой гаммы и других интерфейсных элементов)

2. Проверка границ вводимых значений и других видов корректности входных данных

3. Логичность навигации по задачам

## Задачи пользовательского интерфейса

1. Представление входных и выходных данных

2. Активация функций программной системы (тут активируются функциональные требования)

## Модели пользвателей

1. Новички ("чайники")
> Слабые знания по работе с компьютером и предметной области

2. Стандартный ("обычный") пользователь
> Уверенная работа с компьютером, достаточные знания предметной области

3. Продвидутый пользователь
> Большой опыт работы с компьютером, профессиональные знания предметной области

## Оценка интерфейса пользователя

### Элементы, подлежащие оцениванию

- Виды представления информации (формат данных)
    - Визуальная экспертная оценка (эксперт заполнит анкету, выставляя баллы, а мы потом обрабатываем)
        - Цветовая гамма
        - Понятность названия элементов интерфейса
- Сообщения в ответ на действия пользователя  
Для каждого ФТ определим, какие сообщения могут быть и в каком виде

- Справочная система (система помощи)
    - Сколько в ней информации и в каком она виде:
        - Книга-справочник
        - Диалоговая система (вопрос-ответ)
        - ИИ в виде бота и др.

- Руководство пользователя
    - Все ли требования из спецификации отражены

### Качественная оценка
- Изучаемость (время обученя до начала продуктивной работы)
- Скорость работы (время выполнения функции)
- Устойчивость интерфейса к ошибкам пользователя (?)
- Восстановление после ошибки (время восстановления данных после ошибки/потери, вариаенты восстановления)
- Адаптивность интерфейса (способность подстроиться под стиль работы пользователя, количество вариантов)

### Методики оценивания

1. Анкетирование (пользователь заполняет анкету после работы с интерфейсом)
2. Наблюдение за пользователем (разработчик, который сидит рядом и смотрит (дорого), или видеозапись и анализ пользования ПС)
3. Дополнительный код, который ведет статистику использования ПС (Надо спросить, потому что люди считают, что за ними следят)