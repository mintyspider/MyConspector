# 10. Поиск максимального потока. Алгоритм Форда – Фалкерсона.

## Поиск максимального потока

Условия задачи: рассматривается орграф $G=(V,E)$, $V$ - множество вершин, $E$ - множество ребер. $|V| = n$, $|E| = m$.

Будем считать, что веса $c(e)$ всех дуг не отрицательны. Число $c(e)$ будем называть *пропускной способностью дуги* e.

Предполагаем, что сеть $G = G(V,E,c)$ имеет единственную вершину s с нулевой степенью захода (источник) и единственную вершиной t с нулевой степенью исхода. (сток)

Имеется ориентированный неотрицательный взвешенный граф, в котором вес ребра обозначает пропускную способность между вершинами. Нужно найти максимальный поток, который можно пропустить из истока/начала, в который не может ничего входить, в сток/конец, из которого ничего не может выходить.

::: info <span class="defn">Опр.</span> **Потоком** $f$ в сети $G$ (графа) называется функция $f: E -> R$, удовлетворяющая условиям:
1. 0=< $f(e)$ =< $c(e)$ ANY $e \in E$
2. $f(v^+)$ = $f(v^-)$
ANY $v \in V$, $v \neq s$, $v \neq t$
:::

Поток -  это число, которое проходит через какое-то ребра выходящего из какой-либо точки, при этом удовлетворяющий условиям: 
1. Поток не может быть меньше нуля и не может превышать пропускную способность ребра
2. Сколько потока вошло в точку, столько же потока должно выйти суммарно из всех рёбер точки.
<span class="defn">Опр.</span> Величина потока - число $||f|| = f(s^+)$

**Величина потока** - это число, которое мы ставим в исток/начало графа
<span class="defn">Опр.</span> Максимальный поток - поток $f$ для которого, выполняется неравенство: $||f|| =< ||f*||$, где $f*$ любой другой поток.

Короче, максимальный поток - это тот поток, величина которого наибольшая из всех возможных.

Постановка задачи: Нужно найти максимальный поток.

Данную задачу невозможно решить полным перебором. (Никто не говорил что поток должен быть целым.)

Теорема: В каждой сети (графе) существует максимальный поток.

Поток - это функция непрерывная, но так как она ограничена рёбрами и графом в принципе, то соответственно есть максимум и минимум.

::: info <span class="defn">Опр.</span> **Разрез** - минимальное множество дуг, удаление которых из орграфа приводит к разрушению всех $(v,w)$ - путей.
:::

Разрез - минимальная группа рёбер, удалив которые путь из одной точки в другую невозможен, причём точки могут быть и не близлежащие.

::: info <span class="defn">Опр.</span> Разрезом между истоком и стоком $(V_s,V_t)$ в сети $G$ называется пара множеств $V_s, V_t$, удовлетворяющая условиям: 
1. $s \in V_s$, $t \in V_t$
2. $V_s U V_t = V$
3. $V_s$ Пересечение $V_t = 0$

Эти два множества точек удовлетворяют условиям:
1. Исток в одном множестве, сток в другом.
2. Их объединение равно всему графу
3. Их пересечение должно быть нихуя.
:::

Теорема: Для любого потока $f$ и любого разреза $(V_s, V_t)$ справедливо равенство
$||f|| = f(V_s ->V_t) - f(V_t -> V_s)$

> Суть в том, что для любого потока и любого разреза между истоком и стоком должно выполняться равенство: Величина потока равна (Сумме всех пропускных способностей рёбер ведущих из истока в сток) минус (Сумма всех пропускных способностей рёбер ведущих из стока в исток).

<span class="defn">Опр.</span> Число $c(V_s, V_t) =$ Сумме всех пропускных способностей рёбер из $V_s$ в $V_t$.

Разрез называется **минимальным**, если для любого разреза $(V^*_s, V^*_t)$ справедливо $с(V_s, V_t)=<c(V^*_s, V^*_t)$

Теорема Форда-Фалкерсона
1) Поток максимален
2) В G_f(ост пути) нет пути из S -> t (считается, что обратные ребра в графе есть)
3) Разрез, равный потоку, минимальный. (f = < S, t > , разрез минимальный)

Считается, что утверждения все эквивалентны. Если выполняется одно, то и другие выполняются. Как это можно доказать? Посмотрим, как можно перейти из утв. 2 -> 1. Считаем, что у нас нет никакого пути в ост. сети из s -> t (не можем больше поток пустить), это значит, что поток максимальный.

## Алгоритм Форда – Фалкерсона

Сам Алгоритм:
- В начальный момент времени поток, который мы хотим провести через нашу сеть, должен быть равен нулю. _Остаточная сеть_ совпадает с исходной сетью.
    
- Находим **любой** путь из _истока_ в _сток_ в _остаточной сети._ Если путь не находим, утверждается, что поток является максимальным.
    
- Пускаем через найденный путь поток равный минимальному весу ребра, которое входит в множество рёбер найденного пути.
    
- Из веса рёбер на этом пути высчитываем размер потока, который мы пустили.
    
- А к весу обратных рёбер (будем считать, что они существуют в _остаточной сети_ и равны 0) прибавляем размер потока. Другими словами, на предыдущем шаге мы отправили некоторое количество потока из текущей вершины в следующую**,** а теперь при желании можем вернуть это же количество потока обратно в текущую.
    
- Возвращаемся обратно к нахождению пути в _остаточной сети_ после модификации.

## Алгоритм Форма-Фалкерсона

```псевдо
пока s -> t в G_f :
	пускаем поток 
```

Вместо того, чтобы перестраивать граф, будем в моменте менять остаточную пропускную способность

```cpp
// v - старт (Вершинка), f - поток, который хотим пропустить
f[i][j] // величина потока, который путили по ребру
c[i][j] // пропускная способность
int dfs(int v, int f) {
	if (v == T)
		return f;
	if (was[v] == 1)
		return 0;
	was[v] == 1;
	for (auto to : g[v])
		if(c[v][to] > f[v][to]){
			int t = dfs(to,min(f,c[v][to] - f[v][to]));
			
			if (t !=0) 
				f[v][to] += t; // чтобы запомнить, что п=мы пропустили, хотим запустить потом, при выходе из dfs
				f[to][v] -= t;
				return t;
		}
}

int F = 0;
while(int t = dfs(s, INF)){
	f += t;
}
f = макс. поток;
```

У данного решения асимптотика : O(|f| * n * m) максимальный поток на n на m.