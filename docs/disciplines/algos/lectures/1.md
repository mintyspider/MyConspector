# 1. Графы

## Понятие графа

::: info `def` Граф
это структура данных, состоящая из множества вершин ($V$) и множества рёбер ($E$), соединяющих пары вершин.
:::

Граф - `G<V,E>`, где
+ $V$ - множество вершин
+ $E$ - множество ребер

По ребрам графы делятся на:
+ ориентированные
+ неориентированные

$w: E \rightarrow \mathbb{Z} \ -$ вес ребра.

Обходы:
+ В ширину (BFS - Breadth-First Search) - по уровням
+ В глубину (DFS - Depth-First Search) - по веткам

## Обход в глубину

::: info `def` Поиск в глубину
(Depth-First Search, DFS) — это алгоритм обхода графа, который исследует каждую ветвь до конца, прежде чем возвращаться назад (backtracking). Может быть реализован рекурсивно или итеративно (с использованием стека).
:::

Обход в глубину с помощью рекурсии из лекции:

```cpp
void dfs(int a){
	was[a] = 1; // пометка о том, что вершину посетили
	for (auto v: g[a]){
		if (!was[v]){
			dfs(v);
		}
	}
}
```

Тоже рекурсия, но уже на Python:

```python
def dfs(graph, start):
    visited = set()
    
    def dfs_recursive(v):
        visited.add(v)
        for u, _ in graph[v]:  # graph — список смежности
            if u not in visited:
                dfs_recursive(u)
    
    dfs_recursive(start)
    return visited
```

Стековая версия обхода в глубину на Python:

```python
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]
    
    while stack:
        v = stack.pop()
        if v not in visited:
            visited.add(v)
            for u, _ in graph[v]:
                if u not in visited:
                    stack.append(u)
    return visited
```

## Обход в ширину

Версия с очередью из лекции:

```cpp
queue <int> q; 
q.push(1);
vector <int> d(n, INF);
d[1] = 0;

while(!q.empty()){
int u = q.front();
q.pop();
for (auto v: g[u])
	if(d[u] + 1 < d[v])
		d[v] = d[u] + 1;
}
```

## Компоненты связности

::: info `def` Компонента связности
Множество вершин, где между любыми двумя есть путь, при этом не обязательно прямой.

То есть, можно обвести в кружочек, и по ребрам не пройдем.
:::

::: info `def` Сильная связность
Максимальное подмножество вершин, где существует путь между любой парой вершин в обе стороны.
:::

## Определения дерева
* Связный граф без циклов
* Связный, n-1 ребро, где n - кол-во вершин
* Без циклов, n-1 ребро

Несколько деревьев - это лес.

::: info `tip` Мое замечание
Только $n-1$ ребро в графе с $n$ вершинами не гарантирует нам то, граф будет деревом.
:::


## Кратчайшие пути в графе (с весами)

Это классическая задача на графы, нужно найти меньший вес - самый короткий по длине путь.

Список смежности в таких задачах : 1 : (2, 5) - пара из номера вершины и веса 


```cpp
vector <vector<pair<int,int>>> g;
int u, v, w;
cin >> u >> v >> w;
g[u].push_back({v,w}, {u,w})
```

Матрицу смежности плохо использовать по памяти (O$n^2$).

Список смежности будет хуже, когда хотим узнать вес (O(1)), когда у матрицы смежности O(n).

### Жадные алгоритмы

У нас есть граф с вершинами и весами. Выбираем минимум среди вершин, красим ее.

#### Алгоритм Дейкстры

(Dijkstra - голландский математик)

```cpp
int n, m, start; // n- число вершин, m - число ребер, start - откуда стааартуууеммм
vector <vector<pair<int,int>> g(n); // список смежности
vector<bool> was(n);
vector<int> dist(n, INF);
dist[start] = 0;

// дальше сам алгоритм дядюшки Дейкстры
int next = start, min_dist = 0;
while (min_dist < INF){
	was[next] = true;
	for(auto[v,w]: g[next]){
		dist[v] = min(dist[v], dist[next] + w);
	}

	min_dist = INF;
	for (int u = 0; u < n; ++u){
		if(!was[u] && dist[u] < min_dist){
			min_dist = dist[u]
			next = u;
		}
	}
}
```
Ассимптотика O ($n^2$).

Еще один способ:

```cpp
set<pair<int,int>> st;
u, dist[u];
*(st.begin())
```
Ассимптотика O($\text{log}{n}$).

Правда, теперьмы не сможем быстро обновить данные.