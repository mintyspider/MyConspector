# 7. Минимальные покрывающие деревья. Алгоритм Прима.

## Минимальные покрывающие деревья

G = (V,E) - неориентир. связный граф

w : E -> R - вес ребра

::: info <span class="defn">Опр.</span> **Минимальное остовное дерево** - мин. подграф, связывающий все вершины, при этом сумма ребер - минимальна.
:::

G' = (V,E') 

$$\sum_{(u,v) \in E'} w((u,v)) -> min$$

G = (V,E) - граф, который задан по условию.

Введем понятие "безопасного подграфа"

::: info <span class="defn">Опр.</span> **Безопасный подграф** - это подграф G' = (V,E'), который будет являться подграфом какого-то минимального остовного дерева. (безопасное - все, что является частью мин. остовного дерева).
:::

::: info <span class="defn">Опр.</span> **Безопасное ребро** - такое ребро, что при его добавлении в безопасный подграф новый подграф остается безопасным.
:::

::: info <span class="defn">Опр.</span> **Разрез** - два множества вершин графа, которые не пересекаются.
:::

### Лемма о безопасном ребре

> Самое маленькое по весу ребро в разрезе безопасного подграфа - безопасное.

Докажем лемму. Пусть F - минимальный остав. Тоглда возможны 2 варианта - ребро входит в остов или не входит в остов. Сделаем разрез подграфа.

![](../images/ЛеммаБР.jpg)

Это наш разрез. Возможны 3 варианта развития событий:
1. w1 < w2 - НЕ может быть, т.к. если считаем, что F без ребра w1 - мин. остовное дерево, приходим к противоречию, потому что вместо w2 можем взять w1 и получим сумму меньше, а подграф F - мин. остовное дерево по условию.
2. w1 > w2 - Когда выбирали w1, мы выбирали наименьшее по весу, соответственно, такого быть не может
3. w1 = w2 - Нам не важно, какое ребро брать

В общем, если брать минимальное по весу ребро, то в итоге мы получим минимальное остовное дерево :)

Лемма помогает сделать вывод, что, если мы будем брать всегда min по весу ребро - получим min остовное дерево.

## Алгоритм Прима

**Алгоритм Прима** – это один из алгоритмов построения *минимального остовного дерева (MST)*.

Основан на **лемме о безопасном ребре**.

Идея алгоритма заключается в том, чтобы добавлять ребро минимального веса из произвольной вершины остова в вершину, которая в остове ещё не содержится (т.е. безопасное ребро).

Реализация за $O(n^2)$ для плотных графов:

```cpp
const int maxn = 1e5, inf = 1e9; // Количество вершин и "бесконечность"
bool used[maxn]; // Массив посещённых вершин
vector < pair <int, int> > g[maxn];
int min_edge[maxn] = {inf}, best_edge[maxn];  // Текущее минимальное ребро и то, что попало в MST
min_edge[0] = 0;

// ...

for (int i = 0; i < n; i++) {
    int v = -1;
    for (int u = 0; u < n; u++)
        // Либо цикл начался впервые, либо нашли вершину с меньшим ребром
        if (!used[u] && (v == -1 || min_edge[u] < min_edge[v]))
            // Выйдем из цикла с вершиной с наименьшим ребром
            v = u;
            
    // Отмечаем вершину как посещённую 
    used[v] = 1;
    // Вывод MST
    if (v != 0)
        cout << v << " " << best_edge[v] << endl;
    // Для всех смежных рёбер найденной вершины
    for (auto e : g[v]) {
        // Получаем смежную вершину и стоимость ребра до неё
        int u = e.first, w = e.second;
        // Для смежной вершины сохраняем минимальное ребро и предка в MST
        if (w < min_edge[u]) {
            min_edge[u] = w;
            best_edge[u] = v;
        }
    }
}
```

Также, как в алгоритме Дейкстры, можно не делать линейный поиск оптимальной вершины, а поддерживать его в приоритетной очереди. Получается реализация за $O(m\log⁡n)$ для неплотных графов:
```cpp
set < pair<int, int> > q; // Приоритетная очередь для непосещённых вершин (в порядке минимального ребра до них)
int d[maxn]; // Массив, хранящий текущий минимальный вес до вершины с индексом u

// Пока очередь непуста
while (q.size()) {
    // Из очереди извлечь пару (w, v) и взять вершину
    v = q.begin()->second;
    // Удалить вершину из очереди непосещённых вершин 
    q.erase(q.begin());
    
	// Добавить все смежные вершины
    for (auto e : g[v]) {
        // e – это пара (u, w)
        int u = e.first, w = e.second;
        // Если нашли ребро меньшего веса до вершины, то ставим его в приоритетную         
        // очередь вместо того, что было раньше
        if (w < d[u]) {
            q.erase({d[u], u});
            d[u] = w;
            q.insert({d[u], u});
        }
    }
}
```