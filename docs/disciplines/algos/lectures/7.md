# 7. Минимальные покрывающие деревья. Алгоритм Прима.

Алгоритм Прима – это один из алгоритмов построения *минимального остовного дерева (MST)*.

Основан на **лемме о безопасном ребре**.

Идея алгоритма заключается в том, чтобы добавлять ребро минимального веса из произвольной вершины остова в вершину, которая в остове ещё не содержится (т.е. безопасное ребро).

Реализация за $O(n^2)$ для плотных графов:

```cpp
const int maxn = 1e5, inf = 1e9; // Количество вершин и "бесконечность"
bool used[maxn]; // Массив посещённых вершин
vector < pair <int, int> > g[maxn];
int min_edge[maxn] = {inf}, best_edge[maxn];  // Текущее минимальное ребро и то, что попало в MST
min_edge[0] = 0;

// ...

for (int i = 0; i < n; i++) {
    int v = -1;
    for (int u = 0; u < n; u++)
        // Либо цикл начался впервые, либо нашли вершину с меньшим ребром
        if (!used[u] && (v == -1 || min_edge[u] < min_edge[v]))
            // Выйдем из цикла с вершиной с наименьшим ребром
            v = u;
            
    // Отмечаем вершину как посещённую 
    used[v] = 1;
    // Вывод MST
    if (v != 0)
        cout << v << " " << best_edge[v] << endl;
    // Для всех смежных рёбер найденной вершины
    for (auto e : g[v]) {
        // Получаем смежную вершину и стоимость ребра до неё
        int u = e.first, w = e.second;
        // Для смежной вершины сохраняем минимальное ребро и предка в MST
        if (w < min_edge[u]) {
            min_edge[u] = w;
            best_edge[u] = v;
        }
    }
}
```

Также, как в алгоритме Дейкстры, можно не делать линейный поиск оптимальной вершины, а поддерживать его в приоритетной очереди. Получается реализация за $O(m\log⁡n)$ для неплотных графов:
```cpp
set < pair<int, int> > q; // Приоритетная очередь для непосещённых вершин (в порядке минимального ребра до них)
int d[maxn]; // Массив, хранящий текущий минимальный вес до вершины с индексом u

// Пока очередь непуста
while (q.size()) {
    // Из очереди извлечь пару (w, v) и взять вершину
    v = q.begin()->second;
    // Удалить вершину из очереди непосещённых вершин 
    q.erase(q.begin());
    
	// Добавить все смежные вершины
    for (auto e : g[v]) {
        // e – это пара (u, w)
        int u = e.first, w = e.second;
        // Если нашли ребро меньшего веса до вершины, то ставим его в приоритетную         
        // очередь вместо того, что было раньше
        if (w < d[u]) {
            q.erase({d[u], u});
            d[u] = w;
            q.insert({d[u], u});
        }
    }
}
```