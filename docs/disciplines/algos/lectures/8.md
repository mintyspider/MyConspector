# 8. Минимальные покрывающие деревья. Алгоритм Крускала.

Алгоритм Крускала – это также один из алгоритмов построения *минимального остовного дерева (MST)*.

Основан на **лемме о безопасном ребре**.

Идея алгоритма заключается в том, чтобы отсортировать все ребра и пытаться добавлять их в изначально пустой остов в порядке возрастания их весов.

Порядок алгоритма:
1. Отсортировать все ребра  в порядке возрастания их весов. 
2. Если очередное ребро соединяет какие-то две уже соединенные вершины, то проигнорировать его.
3. Иначе оно является безопасным, так как оно минимальное из соединяющих какие-то две различные компоненты, и его можно добавить.

Основная сложность заключается в п. 2:  если проверять принадлежность к разным компонентам c помощью **DFS**, то асимптотика алгоритма будет $O(nm)$: так как для каждого ребра надо пройтись по всем вершинам компоненты, к которой принадлежит один из концов ребра.

Асимптотику можно улучшить до $O(m\log⁡m)$ – до стоимости сортировки ребер – если для проверок использовать [систему непересекающихся множеств](https://ru.algorithmica.org/cs/set-structures/dsu) (**СНМ**).

За исключением реализации СНМ, код получается очень коротким:

```cpp
struct Edge {
    int from, to, weight;
};

vector<Edge> edges;

sort(edges.begin(), edges.end(), [](Edge a, Edge b) {
    return a.weight < b.weight;
});

for (auto [a, b, w] : edges) {
    // компоненты разные, если лидеры разные
    if (p(a) != p(b)) {
        // добавим ребро (a, b)
        unite(a, b);
    }
}
```
