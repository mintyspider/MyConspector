# 4. Алгоритм Форда – Беллмана.

## Постановка задачи.

Необходимо найти кратчайшие пути между заданной вершиной $v$ и всеми остальными вершинами в графе. Граф допускает рёбра отрицательного веса.
## Описание алгоритма.

Общая идея: искать кратчайшие пути до каждой вершины $u$, содержащие не более $k$ рёбер. Если мы знаем такие кратчайшие пути, то вычислить кратчайшие пути, содержащие $k + 1$ ребро несложно:  чтобы добраться до $u$ мы можем либо воспользоваться старым кратчайшим путём из $k$ рёбер, либо добраться до смежных с $u$ вершин вершин за $k$ рёбер и из них дойти до $u$ за $k + 1$ ребро.

<u>Замечание.</u> Если граф не содержит отрицательных циклов, то кратчайший путь содержит не более, чем $n - 1$ ребро. В самом деле, если это не так, то путь содержит какую-то вершину дважды, а это значит, что путь содержит цикл. Поскольку цикл неотрицательный по предположению, то удалив его из пути, мы не ухудшим результат. Но если мы это сделаем, то мы получим путь из $n - 1$ ребра.

Шаги алгоритма:
1. Заведём массив $d[0\ldots n-1]$. Инициализируем: $d[v] = 0;\  \underset{i\ne v}{d[i]} = \infty$, так как за $0$ рёбер из $v$ достижима сама только сама вершина $v$.
2. Далее $n-1$ раз используем динамику (пытаемся найти кратчайшие пути из $k + 1$ ребра) для попытки улучшения результата: 
$$d[v]= \min (d[v], d[u] + w_{uv})\ \forall (u, v)$$.
3. Если никаких улучшений не произошло (массив не изменился) или цикл завершился $n - 1$ раз, то $d[0\ldots n-1]$ содержит ответ.
4. Опциональный шаг для обнаружения отрицательных циклов. Можно запустить шаг 2 ещё раз: если результат улучшился, значит, существует отрицательный цикл – так как доказано ранее, что искомый путь не может содержать более, чем $n - 1$ ребро.

## Асимптотика алгоритма.

Алгоритмическая сложность алгоритма Форда-Беллмана: $O(|V|* |E|)$, так как $n - 1$ раз просматриваются все рёбра графа в динамике.