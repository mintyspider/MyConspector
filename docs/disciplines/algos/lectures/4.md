# 4. Алгоритм Форда – Беллмана.

## Постановка задачи

Необходимо найти кратчайшие пути между заданной вершиной $v$ и всеми остальными вершинами в графе. Граф допускает рёбра отрицательного веса.
## Описание алгоритма

<u>Общая идея</u>: искать кратчайшие пути до каждой вершины $u$, содержащие не более $k$ рёбер. Если мы знаем такие кратчайшие пути, то вычислить кратчайшие пути, содержащие $k + 1$ ребро несложно: чтобы добраться до $u$ мы можем либо воспользоваться старым кратчайшим путём из $k$ рёбер, либо добраться до смежных с $u$ вершин вершин за $k$ рёбер и из них дойти до $u$ за $k + 1$ ребро.

<u>Замечание.</u> Если граф не содержит отрицательных циклов, то кратчайший путь содержит не более, чем $n - 1$ ребро. В самом деле, если это не так, то путь содержит какую-то вершину дважды, а это значит, что путь содержит цикл. Поскольку цикл неотрицательный по предположению, то удалив его из пути, мы не ухудшим результат. Но если мы это сделаем, то мы получим путь из $n - 1$ ребра.

Шаги алгоритма:
1. Заведём массив $d[0\ldots n-1]$. Инициализируем: $d[v] = 0;\  \underset{i\ne v}{d[i]} = \infty$, так как за $0$ рёбер из $v$ достижима сама только сама вершина $v$.
2. Далее $n-1$ раз используем динамику (пытаемся найти кратчайшие пути из $k + 1$ ребра) для попытки улучшения результата: 
$d[v]= \min (d[v], d[u] + w_{uv})\ \forall (u, v)$.
3. Если никаких улучшений не произошло (массив не изменился) или цикл завершился $n - 1$ раз, то $d[0\ldots n-1]$ содержит ответ.

4*. Опциональный шаг для обнаружения отрицательных циклов. Можно запустить шаг 2 ещё раз: если результат улучшился, значит, существует отрицательный цикл – так как доказано ранее, что искомый путь не может содержать более, чем $n - 1$ ребро.

## Реализация

```cpp
прочитать e // e[0 ... m - 1] - массив, в котором хранятся рёбра и их веса (first, second - вершины, соединяемые ребром, value - вес ребра)
for i = 0 ... n - 1
    d[i] = 2000000000
d[0] = 0
for i = 1 ... n
    for j = 0 ... m - 1
        if d[e[j].second] > d[e[j].first] + e[j].value
            d[e[j].second] = d[e[j].first] + e[j].value
        if d[e[j].first] > d[e[j].second] + e[j].value
            d[e[j].first] = d[e[j].second] + e[j].value
вывести d
```

## Асимптотика алгоритма

Алгоритмическая сложность алгоритма Форда-Беллмана: $O(|V|* |E|)$, так как $n - 1$ раз просматриваются все рёбра графа в динамике.