# 3. Кратчайшие пути. Виды задач поиска кратчайших путей. Поиск кратчайших путей в бесконтурном графе. Про один алгоритм рассказать подробнее.

::: details Оффтопик для понимания происходящего
Вспоминаем ЕГЭ по информатике :)  
У нас есть 2 варианта, что такое кратчайший путь, и он зависит от вида графа:
+ В орграфе мы можем двигаться только согласно направлениям ребер, в неориентированном - как угодно.
+ Мы ищем либо минимальный по *числу ребер* путь, либо по *весу*, если вдруг дан граф с весами. Так что внимательно читаем задание.  
:::

## Кратчайшие пути

::: info Основные определения вопроса 
<span class="defn">Опр.</span> **Кратчайшим путем** между вершинами $а$ и $b$ в графе называется путь между ними, содержащий наименьшее количество ребер.

<span class="defn">Опр.</span> **Взвешенным графом** называется граф, в котором каждому ребру сопоставляется число, называемое *весом*, *длиной* или *стоимостью*.

<span class="defn">Опр.</span> Во взвешенных графах **длиной пути** называется суммарная длина всех его ребер от $а$ до $b$.
:::

::: warning Итого:
Кратчайший путь - минимальный по *числу ребер* либо по *весу* (у взвешенного графа) путь.
:::

## Виды задач поиска кратчайших путей

## Поиск кратчайших путей в бесконтурном графе

### Кратчайшие пути в графе (с весами)

Это классическая задача на графы, нужно найти меньший вес - самый короткий по длине путь.

Список смежности в таких задачах : 1 : (2, 5) - пара из номера вершины и веса 

```cpp
vector <vector<pair<int,int>>> g;
int u, v, w;
cin >> u >> v >> w;
g[u].push_back({v,w}, {u,w})
```

Матрицу смежности плохо использовать по памяти (O$n^2$).

Список смежности будет хуже, когда хотим узнать вес (O(1)), когда у матрицы смежности O(n).

### Жадные алгоритмы

У нас есть граф с вершинами и весами. Выбираем минимум среди вершин, красим ее.

## Про один алгоритм рассказать подробнее

#### Алгоритм Дейкстры

(Dijkstra - голландский математик)

```cpp
int n, m, start; // n- число вершин, m - число ребер, start - откуда стааартуууеммм
vector <vector<pair<int,int>> g(n); // список смежности
vector<bool> was(n);
vector<int> dist(n, INF);
dist[start] = 0;

// дальше сам алгоритм дядюшки Дейкстры
int next = start, min_dist = 0;
while (min_dist < INF){
	was[next] = true;
	for(auto[v,w]: g[next]){
		dist[v] = min(dist[v], dist[next] + w);
	}

	min_dist = INF;
	for (int u = 0; u < n; ++u){
		if(!was[u] && dist[u] < min_dist){
			min_dist = dist[u]
			next = u;
		}
	}
}
```
Ассимптотика O($n^2$).

Еще один способ:

```cpp
set<pair<int,int>> st;
u, dist[u];
*(st.begin())
```
Ассимптотика O($\text{log}{n}$).

Правда, теперьмы не сможем быстро обновить данные.