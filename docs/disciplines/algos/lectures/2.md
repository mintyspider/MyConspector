# 2. Кратчайшие пути

::: info `def` Кратчайший путь
Кратчайшим путем между вершинами а и b в неориентированном графе называется путь между ними, содержащий наименьшее количество ребер.
:::

Пусть дан граф
![[Алгосы, 2 лекция, граф 1]]


1) S - исток , $d_s$[i] - кратчайшее расстояние от вершинки S до вершинки i
Утверждение:
Пусть есть вершинка S и t
рассмотрим кратчайшее расстояние:
$$p: \text{S -> a_1 -> a_2 -> a_3 -> ... -> a_i -> ... -> a_k -> t}$$

Докажем, что от s до a_i - кратчайший путь
МОП: пусть есть другой путь, его длина $d_2$ , а $d_1$ - исходный путь наш

$d_2$ < $d_1$

Значит уже не кратчайший($d_3$ - путь от $a_i$ до t)

$d_1 + d_3$ 
$d_2 + d_3$

Если есть один кратчайший путь, значит от проходит по всем кратчайшим путям

![[Алгосы, 2 лекция, граф 2]]
1) d = 0 (длина цикла = 0)
2) d > 0
3) d < 0 (длина пути отрицательное) в таком случа кратчайшего пути не существует(т.к. можем ходить по циклу, будет все меньше и меньше путь, значит нет смысла искать кратчайший путь)
## Дейкстра с помощью множеств(для разряженных графов)

Пусть граф хранится в виде списка смежности: g[v] = $\{u_1,u_2,u_3,...,u_k\}$

Пусть у нас есть рассмотренный подграф, есть вершинки, которые мы не добавили в подграф

![[Алгосы, 2 лекция, граф 3]]



циклом выполняем n раз, каждый раз, дополняя вершинку
будем через set делать, пока у нас в set что-то есть


$\delta(s,v)$ - кратчайший путь из s -> v(то есть функция)
$\delta(s,v)$ <= d[v] - ослабляем ограничение 

```cpp
d[v] // min расстояние от s до v
// в списке смежности кроме вершины и расстояние есть
d[S] = 0, d[i] = INF, т.ч. i != S;
set<pair<int,int>> dist;  // в паре будем хранить расстояние до вершинки , саму вершину соответственно {d[v], v}
set.insert({0,5});

while(set.size() > 0){
	v = set().begin() -> second;
	set.erase(...); // удаляем эту вершинку это все за логарифм за кол-во эл-тов в set(не больше n элементов)
	for (auto {to,w} : g[v]){ // O(m) - числа ребер
	//релоксация(ослабление какого-то значения, т.к d[i] - не кратчайший путь, а оценка кратчайшего пути сверху) 
		// а правда, что расстояние, которое сейчас найдем, будет меньше предыдущего?
		if(d[v] + w < d[to] ){
			set.erase({d[to],to})
			d[to] = d[v] + w; // в set надо поддерживать правильные значения, нужно в set также обновить(удаляем и снова добавляем)
			set.insert({d[to],to}) // удаляем и добавляем за O(log(n))
		}
		
	}

}
```
Каждую вершинку не более одного раза рассматривать будем

O((n + m) log(n))

На плотный графах m ~~ $n^2$
$O(n^2) * log(n)$
Тогда лучше брать за $O(n^2)$ алгоритм Дейкстры

Set удаляет и добавляет долгоуууу, лучше использовать очередь с приоритетом(priority-queue - обычная очередь, сортирующая по min) (добавление - log n , поиск - log n)

Если вместо set брать очередь с приоритетом, то не можем удалять(обновлять расстояния). Будут пары вида $\{d_1,to\} \{d_2,to\}$, то есть одинаковые вершины. Поменяется асимптотика(т.к. в set не более n эл, а в очереди больше n)
Когда берем min значение - брать, min ли значение.

Докажем, какая асимптотика будет:

> для вершинки v можем изменить расстояния до вершины не более, чем кол-во смежных вершин(суммарно можем обновить не больше m раз) O(m)

Каждое ребро добавляет возможности обновить расстяние(от u до v допустим) (так то 2n, но 2 выкидываем)


O((n + m) * log(m)) - при этом в реальной работе в большинстве случаях очередь будет работать чуть быстрее(т.к. set долго добавляет и убирает)

## Алгоритм Форда-Беммана

В случаях с Дейсткстра - жадность была(брали min)

> Давайте заметим, что в кратчайшем пути будет не более, чем(<=) n - 1 ребро. Всего различных вершинок n - 2(в промежуточных вершинах), тогда ребер не более, чем n - 1. Идея: путь будем составлять по ребрам, будем начинать с вершинки S, будем пытаться релаксировать очередным ребром


![[Алгосы, 2 лекция, граф 4]]

```cpp
d[s] = 0;
d[i] = INF;

for (int 

i = 1; i < n; i++){ // O(n)
	for (int j = 0; j < m; j++){ // O(m) (итого O(n * m))
		if(d[t_j] > d[f_j] + w_j)
			d[t_j] = d[f_j] + w_j 
	}
}

```

Почему работает? 
![[Алгосы, 2 лекция, граф 5]]
Что происходит, когда ребро отрицательного веса(Дейскстра - все плохо, продолжает работу)

Заметим факт: т.к в if знак больше, то будем изменять расстояние, когда у нас расстояние строго меньше. По пути цикла длины 0 не пойдем, положительной - тоже, отрицательной -в нашем кратчайшем пути будет больше, чем n - 1 вершинка. После того, как мы знакончим, можем пробежаться по всем ребрам


```cpp
//проделали предыдущий код, вышли из всех циклом
for(j = 0 ... m)
	if(d[t_j] > d[f_j] + w_j)
		// есть цикл отрицательного веса!

```

Мы найдем эту ситуацию и не будем работать бесконечно. Если граф большой, то получим $O(n^3)$ , что ощутимо. 

Хотим найти все кратчайшие пути между всеми парами вершин.

То есть некую матрицу D[n][n] такую, что 
$$d_{i,j} : \begin{cases} 0, i =j \\ 0(i,j),\ есть\ i -> j, \\ \pinfinity i !-> j \end{cases}$$

Если возьмем Дейкстру, то получим n * O((n + m) * log n * n), это страшная асимптотика, с Фордом также

Случаи:

1) $O(n^3 * log n)$ - перемножение матриц
2) Флойда-Варшалл - $O(n^3)$ .

Идея Флойда: 
> Динамика, пути будем строить след. образом: 

![[Алгосы, 2 лекция, граф 6]]