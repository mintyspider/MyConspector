# 5. Алгоритм Флойда.

## Постановка задачи

Необходимо найти расстояния от всех вершин графа до всех остальных.
## Описание алгоритма
<u>Общая идея</u>: искать кратчайшие пути между всеми вершинами, постепенно добавляя в них новые доступные для посещения промежуточные вершины.

Допустим, мы знаем кратчайший путь между вершинами $i$ и $j$, который может содержать в себе в качестве промежуточных вершин: $\{0, 1, \ldots k\}$. Тогда, если мы добавим в множество доступных для посещения промежуточных вершин $k + 1$, то мы можем использовать либо старый путь, либо добраться от вершины $i$ к вершине  $k+1,$ а от вершины $k+1$ к вершине $j$.

Заметим, что кратчайшие расстояния от $i$ к $k+1$ и от $k+1$ к $j$ нам известны, так как содержат $k+1$  в качестве промежуточной вершины.

Шаги алгоритма:
1. Заведём двумерный массив $d[0\ldots n-1][0\ldots n-1]$. Инициализируем: $d[i][j] = a[i][i]$, где $a$ – матрица смежности, так как не используя никаких промежуточных вершин для перехода можно использовать только прямые соединения.
2.  Далее $n$ раз используем динамику (пытаемся найти кратчайшие пути, содержащие $k$ промежуточную вершину):
$$d[i][j] = \min (d[i][j],\ d[i][k] + d[k][j])$$
3. Когда алгоритм завершается, $d[i][j]$ содержит кратчайшее расстояние между вершинами $i$ и $j$.

## Реализация
```cpp
прочитать g // g[0 ... n - 1][0 ... n - 1] - массив, в котором хранятся веса рёбер, g[i][j] = 2000000000, если ребра между i и j нет
d = g
for i = 1 ... n + 1
     for j = 0 ... n - 1
          for k = 0 ... n - 1
              if d[j][k] > d[j][i - 1] + d[i - 1][k]
                  d[j][k] = d[j][i - 1] + d[i - 1][k]
вывести d
```

## Асимптотика алгоритма

Асимптотическая сложность алгоритма Флойда-Уоршелла: $O(|V|^3)$.