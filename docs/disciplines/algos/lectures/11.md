# 11. Поиск максимального потока. Алгоритм Диница.

## Поиск максимального потока

## Поиск максимального потока

Условия задачи: рассматривается орграф $G=(V,E)$, $V$ - множество вершин, $E$ - множество ребер. $|V| = n$, $|E| = m$.

Будем считать, что веса $c(e)$ всех дуг не отрицательны. Число $c(e)$ будем называть *пропускной способностью дуги* e.

Предполагаем, что сеть $G = G(V,E,c)$ имеет единственную вершину s с нулевой степенью захода (источник) и единственную вершиной t с нулевой степенью исхода. (сток)

Имеется ориентированный неотрицательный взвешенный граф, в котором вес ребра обозначает пропускную способность между вершинами. Нужно найти максимальный поток, который можно пропустить из истока/начала, в который не может ничего входить, в сток/конец, из которого ничего не может выходить.

::: info <span class="defn">Опр.</span> **Потоком** $f$ в сети $G$ (графа) называется функция $f: E -> R$, удовлетворяющая условиям:
1. 0=< $f(e)$ =< $c(e)$ ANY $e \in E$
2. $f(v^+)$ = $f(v^-)$
ANY $v \in V$, $v \neq s$, $v \neq t$
:::

Поток -  это число, которое проходит через какое-то ребра выходящего из какой-либо точки, при этом удовлетворяющий условиям: 
1. Поток не может быть меньше нуля и не может превышать пропускную способность ребра
2. Сколько потока вошло в точку, столько же потока должно выйти суммарно из всех рёбер точки.
<span class="defn">Опр.</span> Величина потока - число $||f|| = f(s^+)$

**Величина потока** - это число, которое мы ставим в исток/начало графа
<span class="defn">Опр.</span> Максимальный поток - поток $f$ для которого, выполняется неравенство: $||f|| =< ||f*||$, где $f*$ любой другой поток.

Короче, максимальный поток - это тот поток, величина которого наибольшая из всех возможных.

Постановка задачи: Нужно найти максимальный поток.

Данную задачу невозможно решить полным перебором. (Никто не говорил что поток должен быть целым.)

Теорема: В каждой сети (графе) существует максимальный поток.

Поток - это функция непрерывная, но так как она ограничена рёбрами и графом в принципе, то соответственно есть максимум и минимум.

::: info <span class="defn">Опр.</span> **Разрез** - минимальное множество дуг, удаление которых из орграфа приводит к разрушению всех $(v,w)$ - путей.
:::

Разрез - минимальная группа рёбер, удалив которые путь из одной точки в другую невозможен, причём точки могут быть и не близлежащие.

::: info <span class="defn">Опр.</span> Разрезом между истоком и стоком $(V_s,V_t)$ в сети $G$ называется пара множеств $V_s, V_t$, удовлетворяющая условиям: 
1. $s \in V_s$, $t \in V_t$
2. $V_s U V_t = V$
3. $V_s$ Пересечение $V_t = 0$

Эти два множества точек удовлетворяют условиям:
1. Исток в одном множестве, сток в другом.
2. Их объединение равно всему графу
3. Их пересечение должно быть нихуя.
:::

Теорема: Для любого потока $f$ и любого разреза $(V_s, V_t)$ справедливо равенство
$||f|| = f(V_s ->V_t) - f(V_t -> V_s)$

> Суть в том, что для любого потока и любого разреза между истоком и стоком должно выполняться равенство: Величина потока равна (Сумме всех пропускных способностей рёбер ведущих из истока в сток) минус (Сумма всех пропускных способностей рёбер ведущих из стока в исток).

<span class="defn">Опр.</span> Число $c(V_s, V_t) =$ Сумме всех пропускных способностей рёбер из $V_s$ в $V_t$.

Разрез называется **минимальным**, если для любого разреза $(V^*_s, V^*_t)$ справедливо $с(V_s, V_t)=<c(V^*_s, V^*_t)$

Теорема Форда-Фалкерсона
1) Поток максимален
2) В G_f(ост пути) нет пути из S -> t (считается, что обратные ребра в графе есть)
3) Разрез, равный потоку, минимальный. (f = < S, t > , разрез минимальный)

Считается, что утверждения все эквивалентны. Если выполняется одно, то и другие выполняются. Как это можно доказать? Посмотрим, как можно перейти из утв. 2 -> 1. Считаем, что у нас нет никакого пути в ост. сети из s -> t (не можем больше поток пустить), это значит, что поток максимальный.

## Алгоритм Диница

<span class="defn">Опр.</span> Пусть в сети G построен некоторый поток f. Определим остаточное ребром как меру того, насколько еще можно увеличить поток вдоль этого ребра:
$(u,v)$ с пропускной способностью $C^R_{uv} =C_{uv} - f_{uv}$;
$(v,u)$ с пропускной способностью $C^R_{uv} = f_{uv}$

%%Тупо отнимаешь от пропускной способности ребра значение потока и получаешь остаточное ребро.%%

<span class="defn">Опр.</span> Остаточной сетью $G^R$ по отношению к сети $G$ и некоторому потоку $f$ в ней называется сеть, в которой каждому ребру $(u,v)\in G$ с пропускной способностью $C_{uv}$ и потоком $f_uv$ соответствуют остаточное ребро.

<span class="defn">Опр.</span> Для всех вершин, кроме истока $s$, определим длины кратчайших путей из $s$ и назовём уровнем $level[v]$ вершины её расстояние от истока.
> Расставляем уровни в зависимости от того, как далеко вершина от истока, измеряя не вес рёбер, а кол-во вершин, которое нужно пройти. Причем вершины с большим уровнем не могут переходить в вершины с меньшим уровнем.

<span class="defn">Опр.</span> В слоистую сеть включают все те ребра $(u,v)$ исходной сети, которые ведут с одного уровня на какой-либо другой, более поздний уровень, т.е. $level[u] + 1 = level[v]$

Для того, чтобы построить слоистую сеть по данной сети нужно, запустить обход в ширину по рёбрам этой сети, посчитав тем самым для каждой вершины величину, $level[]$, и затем внести в слоистую сеть все подходящие ребра.

<span class="defn">Опр.</span>Блокирующий поток в данной сети называется такой поток, что любой путь из истока $s$ в сток $t$ содержит насыщенное этим потоком ребро. Иными словами, в данной сети не найдётся такого пути из истока в сток, вдоль которого можно беспрепятственно увеличить поток.
Это не обязано быть максимальным потоком.

Сам алгоритм это:
1. Строишь остаточную сеть.
2. По отношению к ней строишь слоистая сеть.
3. В слоистой сети ищешь произвольный блокирующий поток. 
4. Прибавляешь Блокирующий поток к изначальному.
5. Мои поздравления, ты нашел Максимальный поток.

```cpp
// строим слоистую сеть
while крат s -> t в G_f (ост сеть - убираем те ребра, которые заполнены потоком)
	while есть s ->t 
		пускаем поток
```

будем ходить только по увеличению от расстояния от s до t (слои).  

Как бы совмещаем Алгоритм Форда-Фалкерсона и Эдмундса-Карла.

$O(V * E^2)$ или $O(V^2 * E)$, плюс, если использовать для построения и проверки кратчайшего пути динамические деревья Тарьяна, то получим $O(V* E * logV)$.

Когда Диница лучше всего помогает? Поиск. макс. паросочет. Когда ребер много, но все ребра с макс. пропуск. способность 1.  
Каждый поток по сути +1 к паросочет. F = макс. паросочет. Когда такой граф, то Диница может работать за более приятную асимптотику: O(E * sqrt(V)) с точки зрения поиска макс. паросочет - самое приятное. Кун работает на V \* E.