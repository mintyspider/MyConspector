# 15. Префикс функция, Алгоритм Кнута – Морриса – Пратта.

## Определения

<span class="defn">Опр.</span> *Префиксом* строки $l$ называется такая подстрока $p$, что $p$ начинается с начального символа строки $l$.

<span class="defn">Опр.</span> Префикс называется *собственным*, если длина префикса не равна длине строки. 

<span class="defn">Опр.</span> *Суффиксом* строки $l$ называется такая подстрока $s$, что $s$ заканчивается конечным символом строки $l$.

<span class="defn">Опр.</span> Суффикс называется *собственным*, если длина суффикса не равна длине строки. 

<span class="defn">Опр.</span> Пусть дана строка $l$. Обозначим $l_i$ префикс $l$ до $i$-ой позиции включительно. *Префикс-функцией строки $l$* называется массив, в котором на $i$-ой позиции стоит длина наибольшего собственного префикса $l_i$, который является и суффиксом $l_i$.

<u>Замечание.</u> На нулевой позиции префикс-функции всегда будет стоять $0$, так как для строки из единственного символа и собственный префикс, и собственный суффикс будет пустой строкой.

## Поиск подстроки в строке с помощью префикс-функции

```cpp
for i = 0...n
	for len = 0...i-1
		 if s[0...len-1] == s[i-len...i]
			 ...
```

O(n^3)

Заведем функцию. которая будет возвращать значение префикс-функции. 

```cpp
vector<int>pref(string S);
int p[s.size()];
p[0] = 0; // иначе не совсем понятно, что туда писать
for i = 1...n {  // O(n)
	int it =  p[i-1]; // указывает на тот суффикс, который мы рассматриваем
	while (s[i] != s[it] && it > 0) // а сколько суммарно пройдем итераций?  // > 0 , т.к. когда-то ведь строка закончится
		it = p[it - 1]; // берем предыдущую позицию
	if (s[i] == s[it] )
		p[i] = it + 1; // префикс увеличился
	
}
```

it можем увеличить на единицу (не больше n)  
it - x >= 0 (не больше n)

асимптотика будет суммироваться, т.к. while не полностью за O(n) работает, получается O(n)

---

Пусть у нас есть строка $heystack$ длины $n$ и искомая подстрока $needle$ длины $m$.

Соединим $needle$ с $heystack$ через символ, который не встречается в обоих их алфавитах, например: "#".  Назовём получившуюся строку $joined$. 

Посчитаем префикс-функцию $p$ для $joined$. 

Очевидно, что значения $p[i]$ не могут превосходить $m$. Действительно, если превосходящее значение существует, то это означает, что нашлась подстрока $joined$ длины $m + 1$, отличная от собственного префикса, содержащая символ "#" на той же позиции, что и собственный префикс. Но это означает, что символов "#" как минимум два, что невозможно по построению.

Более того, если значение $p[i]$ равно $m$, то это означает, что первые $m$ символов $joined$ (в точности $needle$) равны какой-то подстроке $joined$, отличной от $needle$. А по построению, это означает, что $needle$ нашлась в $heystack$, что нам и требовалось. Осталось вычесть $2m$ (так как мы находим *концы* вхождений и первые $m + 1$ символ не входят в $heystack$) из всех $i$, где $p[i] == m$. 

## Асимптотика

Если префикс-функция для $joined$ уже построена, то достаточно один раз пройтись по $p[i]$, следовательно, асимптотика равна $O(n)$. Быстрое построение префикс-функции также требует $O(n)$ времени, следовательно, общая асимптотика алгоритма Кнута-Морриса-Пратта занимает $O(n)$. 